{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Candara;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs44 \cf2 (\
\cf3 // main variation variables:\cf2 \
		\cf4 var\cf2  variation = 440;\
		\cf4 var\cf2  piecelength = 40;\
\
\cf3 // main functions:\cf2 \
		\cf4 var\cf2  isEven = \{\cf4 arg\cf2  n;\
			(n%2==0);\
		\};\
		\
		\cf4 var\cf2  getDur = \{\cf4 arg\cf2  dur, length;\
			(dur / (variation / length));\
		\};\
		\
		\cf4 var\cf2  getPrimes = \{ \cf4 arg\cf2  n;\
			\cf4 var\cf2  tempPrimes = \cf4 Array\cf2 .new();\
			\cf4 var\cf2  p = \cf4 Array\cf2 .series(n, 2, 1); \cf3 // fill array p with [2 through n]\cf2 \
			while ( \{ p.size > 0 \}, \{ \
				x = p[0];\
				tempPrimes = tempPrimes.add(x);\
				p.removeAllSuchThat(\{ \cf4 arg\cf2  item, i; item % x == 0 \});\
			 \});\
			tempPrimes;\
		\};\
		\
		\cf4 var\cf2  getFactors = \{ \cf4 arg\cf2  n;\
			\cf4 var\cf2  factors;\
			if(n.even)\
				\{forBy (2, sqrt(n), 2, \
				  	\{ \cf4 arg\cf2  i; \
					  	if (n%i==0 && isEven.value(n/i))\
					  	\{factors = factors.add([i,n/i])\}\
					\});				\
				\}\{ \cf5 "the number is odd"\cf2 \};\
			factors;\
		\};\
		\
		\cf4 var\cf2  getGoldbach = \{ \cf4 arg\cf2  n;\
			\cf4 var\cf2  testPrimes = getPrimes.value(n);\
			\cf4 var\cf2  results = \cf4 Array\cf2 .new();\
			for (0, testPrimes.size-1, \{\cf4 arg\cf2  i;\
				if (testPrimes.includes(n-testPrimes[i]),\
					\{results = results.add([testPrimes[i], n-testPrimes[i]])\}\
				);\
			\});\
			results\
		\};\
\
\cf3 // boot server\cf2 \
	\cf4 Server\cf2 .default = s = \cf4 Server\cf2 .internal.boot;\
	s.scope;		\
	s.waitForBoot(\{	\
\
		\cf3 // prepare buffer\cf2 \
		\cf4 var\cf2  data, routFunction, sd, myBuffers, 		cond;\
		cond = \cf4 Condition\cf2 .new;\
		myBuffers = \cf4 List\cf2 .new(1);\
		myBuffers.add(\cf4 CtkBuffer\cf2 .buffer(8192, server: s).load);\
		myBuffers[1].sine1(0.0, 1, 1, 1, 1);\
\
\cf3 //		myBuffers[2].sine1(0.0, 1, 1, 1, 0.5, 0.8, 0.4, 0.2, 0.9);\cf2 \
\cf3 //		myBuffers[3].sine1(0.0, 1, 1, 1, 1.0, 0.2, 0.7, 0.1, 0.6, 0.1, 0.8);\cf2 \
		\
		s.sync(cond);\
		\cf5 "Buffers are loaded!"\cf2 .postln;\
		\
		\cf4 CmdPeriod\cf2 .doOnce(\{\
			\cf5 "Freeing Buffers"\cf2 .postln;\
						myBuffers.do(\{\cf4 arg\cf2  thisBuffer;\
				thisBuffer.free;\
			\})\
\
		\});\
		\
		\
		\cf3 // define SynthDef\cf2 \
		sd = \cf4 CtkSynthDef\cf2 (\cf6 \\note\cf2 , \{\cf4 arg\cf2  buffer, freq, amp, dur;\
			\cf4 var\cf2  env;\
			env = \cf4 EnvGen\cf2 .kr(\
				\cf4 Env\cf2 ([0, 1, 1, 0], [0.1, 0.8, 0.1], \cf6 \\sin\cf2 ), \
				timeScale: dur);\
			\cf4 Out\cf2 .ar(0, \cf4 Pan2\cf2 .ar(\
				\cf4 Osc\cf2 .ar(buffer, freq, 0, amp) * env\
				)\
			)\
		\});\
\
		routFunction = \{\cf4 arg\cf2  fundamental = variation, length = piecelength, buffer = myBuffers[1], pause = 0, amp = 0.2;\
			\cf4 var\cf2  routine;\
			\cf4 var\cf2  partitions = getGoldbach.(fundamental);			routine = \cf4 Routine\cf2 (\{\
				pause.wait;\
				partitions.do(\{\cf4 arg\cf2  thisData, i;\
					\cf4 var\cf2  freq, dur;\
					#freq, dur = thisData;\
					dur = getDur.value(dur, length);\
					sd.note(0.2, dur).buffer_(buffer).freq_(freq).dur_(dur).amp_(amp).play;\
					\
				\});\
			\});\
			routine;	\
		\};\
	\
		\cf4 Routine\cf2 .run(\{	\
			\cf4 var\cf2  factors, length, routine, pause;\
			routFunction.value().play;\
			factors = getFactors.value(variation);\
					factors.do(\{\cf4 arg\cf2  thisData, i;\
						\cf4 var\cf2  freq, dur;\
						#dur, freq = thisData;\
						freq.postln;\
						dur.postln;\
						routFunction.value(fundamental: freq, length: piecelength-dur, pause:dur).play;\
					\});	\
		\})\
\}) \cf3 // end wait for boot	\cf2 \
)\
\
\
}