/* 
An Introduction to scsynth (the synthesis server)
*/
/* scsynth is the second program we will be using (in a way). It is the 'synthesis server' that makes sound. The SuperCollider language, while able to describe a synthesis process, does not synthesize or process any sound. In the language, it is represented by the 'Server' object - and there are two servers that a 'pre-loaded' for you. We will mostly use the 'internal' server. This server is connected to the same memory space as the language, which gives us some nice features. By default, the single letter variable 's' is used for the server, and inside the Server class, there is a special variable for default Servers as well that many parts of the language look for. This line of code will be handy in your work:
*/

Server.default = s = Server.internal;

// start the server - tells it to start the scsynth process, and to 
// start listening for commands from the language

s.boot;

// we can also quit it

s.quit;

/* 
The server really knows nothing about the language. The language and the server communicate with each other using a network protocol (OSC). All synthesis processes need to be defined in the language, then sent over the network as an OSC message. The language does a lot of this for you, and provides a class called SynthDef to describe synthesis processes. The code below is a quick sample so you can make sound... don't worry about the details yet - THIS is a huge part of this class!
SynthDefs take a \symbol name and a Function 
*/

// define a synthesis process
a = SynthDef(\mySynthDef, {arg freq;
	Out.ar(0, Pan2.ar(SinOsc.ar(freq, 0, 0.3)))
});

// 'load' it to the Server s
a.load(s);

// send an OSC message to the server
s.sendMsg(\s_new, \mySynthDef, 1000, 0, 1, \freq, 540);
s.sendMsg(\n_free, 1000);

// OSC messages are a bit icky. There are other classes you will see
// that handle them for you

b = Synth(\mySynthDef, [\freq, 440]);
b.free;

// Function has a 'play' method that does a number of the above steps for you!
// great for prototyping and testing - not so good for performance

c = {Pan2.ar(SinOsc.ar(440, 0, 0.3))}.play;
c.free;

/* 
The Composer's ToolKit (Ctk) and differences with the SuperCollider abstraction Objects.

We dont' have time right now to go into all the reasons why, but the class above (Synth) which is in MANY SuperCollider Help and references has a number of problems. The primary one being that it doesn't work very well if you have to render your materials off-line (in Non-Real-Time). As a result, there is a library of tools that have been built for you that are more flexible and are also more suited to the rest of the SuperCollider language. Ctk is an extension Quark that you will see all class examples in. However, here is a quick introduction to a couple Ctk tools that will help you if you look at Help files this weekend!
*/

// 'Normal' SuperCollider = SynthDef
a = SynthDef(\mySynthDef, {arg freq;
	Out.ar(0, Pan2.ar(SinOsc.ar(freq, 0, 0.3)))
}).load(s);

// Ctk - CtkSynthDef - no need to load - it does it for you
a = CtkSynthDef(\mySynthDef, {arg freq;
	Out.ar(0, Pan2.ar(SinOsc.ar(freq, 0, 0.3)))
});

// create a 'Synth' - this is basically a formatter for OSC messages, nothing else
b = Synth(\mySynthDef, [\freqs, 440]); // plays automatically
b.set(\freq, 550);
b.free;

// Ctk - uses the CtkSynthDef as a prototype for the notes... send it the 'note' message
b = a.note;
b.freq_(550);
b.freq; // CtkNotes store info like other instance of a class
b.play;
// change a parameter by setting another value:
b.freq_(660);
b.free;

/*
Interaction between the language and the server - a quick demo
*/

// boot the server...

Server.default = s = Server.internal;
s.boot;
// turn on the scope... this shows the samples that are being written to the output
s.scope;

// now - execute this code block. It will create a 10 second sine tone
// you can move the mouse around to change pitch

(
var synth, note;

synth = CtkSynthDef(\myTest, {
	Out.ar(0, Pan2.ar(
		SinOsc.ar(
			MouseX.kr(300, 600, \exponential)
			)
		)
	)
});

note = synth.note(0.0, 10.0).play;
)

Help.gui
Quarks.gui
Platform.userAppSupportDir
Quarks.install("Ctk")

Quarks.installed
Quarks.updateDirectory 

Quarks.local.quarks
Quarks.repos.quarks
Quarks.listAvailable 