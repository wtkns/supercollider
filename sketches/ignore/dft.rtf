{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\b\fs36 \cf0 1) Discrete Fourier Transform definition:\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1 \cf0 X[k] = 1/N sum\{n = 0, N-1\} x[n] e^-j Wk nT\

\fs32 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\fs36 \cf0 X[k] = complex-valued spectrum of x[n] at frequency Wk\
k = frequency sample counter\
Wk = kth radian frequency = k * (2\uc0\u960  * fs/N)(rad/sec)\
n = time sample counter\
T = sampling interval = 1/fs\
N = number of samples (in time and frequency)
\f0 \
\
\'95 For fs=1, we can rewrite:\
\

\f1 X[k] = 1/N sum\{n = 0, N-1\} x[n] e^-j k n 2\uc0\u960 /N\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0 \cf0 \
\'95 We can define the DFT at frequency 
\i k
\i0  as the sum of the 
\i N
\i0  samples of the product of the input signal 
\i x[n] 
\i0 and a sampled complex sinusoid of frequency 
\i Wk
\i0 .\
\
\'95 Let's implement the DFT as a function, for this we can re-write its formula, using Euler's identity:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f1 \cf0 e^-j k n 2pi/N = cos(k n 2pi/N) - j sin(k n 2pi/N)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0 \cf0  \
 then:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f1 \cf0 X[k] = 1/N sum\{n = 0, N-1\} x[n] [cos(k n 2pi/N) - j sin(k n 2pi/N)]\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f1 \cf0 (\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf2 // discrete fourier transform of real signal x\
// returns complex spectrum\cf0 \
~dft = \{ \cf3 arg\cf0  x;\
	\cf3 var\cf0  big_n, twopi_over_n;\
	big_n = x.size;\
	twopi_over_n = 2pi/big_n;\
	big_n.collect(\{ \cf3 arg\cf0  k;\
		big_n.collect(\{ arg n;\
			\cf3 Complex\cf0 (x[n], 0.0) *\
			\cf3 Complex\cf0 (cos(twopi_over_n * k * n), sin(twopi_over_n * k * n).neg);\
			\}).sum;\
		\}) * big_n.reciprocal;\
	\}\
)\
\cf2 \
// test it with simple 10Hz sinusoid\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 n = 64;\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf0 x = \cf3 Signal\cf0 .newClear(n);\
x.sineFill2([[10.0, 1.0, 0.0]]);\
x.plot;	\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf2 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf0 ~dft.value(x).magnitude.plot(minval: 0.0, maxval: 1.0);\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf2 // try using a mix of sinusoids as test signal\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf0 y = \cf3 Signal\cf0 .newClear(n);\
y.sineFill2([[10.0, 1.0, 0.0],[20.0, 0.5, 0.25pi],[30.0, 0.25, 0.5pi]]);\
y.plot;\cf2 \
\cf0 \
~dft.value(y).magnitude.plot(minval: 0.0, maxval: 1.0)
\f0 ;\
\
\'95 remember the DFT returns N frequency samples between 0 and fs\
then the Nyquist frequency corresponds to sample N/2\
in our example N=64, then the Nyquist frequency sample is N/2=32\
which is also our Nyquist freq. as T = 1" (we are using normalized frequency),\
so we should be careful about aliasing:\
\

\f1 z = \cf3 Signal\cf0 .newClear(64);\
z.sineFill2([[10.0, 1.0, 0.0],[20.0, 0.5, 0.25pi],[30, 0.25, 0.5pi], [40, 0.125, pi]]);\
z.plot;\cf2 \
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf2 // 40Hz folds over to: n - 40 = 64 - 40 = 24\cf0 \
~dft.value(z).magnitude.plot(minval: 0.0, maxval: 1.0);\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\b \cf0 1) Inverse Discrete Fourier Transform definition:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f1\b0 \cf0 x[n] = sum\{k = 0, N-1\} X[k] e^jWk nT\
\
x[n] = real-valued output signal\
X[k] = complex-valued spectrum of x at frequency Wk\
k = frequency sample counter\
n = time sample counter\
Wk = kth radian frequency = k * (2\uc0\u960  * fs/N)(rad/sec)\
T = sampling interval = 1/fs\
N = number of samples (in time and frequency)
\f0 \
\
\'95 For fs=1, we can rewrite:\
\

\f1 x[n] = sum\{k = 0, N-1\} X[k] e^j k n 2\uc0\u960 /N\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0 \cf0 \'95 We can define the Inverse DFT as the sum of the 
\i N
\i0  samples of the product of the complex spectrum 
\i X[k] 
\i0 and a complex sinusoid of frequency 
\i Wk
\i0 .\
\
\'95 Let's implement the IDFT as a function, for this we can re-write its formula, using Euler's identity:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f1 \cf0 e^jk n 2pi/N = cos(k n 2pi/N) + j sin(k n 2pi/N)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0 \cf0  \
 then:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f1 \cf0 x[n] = sum\{k = 0, N-1\} X[k] [cos(k n 2pi/N) + j sin(k n 2pi/N)]\
\
(\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf2 // inverse discrete fourier transform of complex spectrum xk\cf0 \
~idft = \{ \cf3 arg\cf0  xk;\
	\cf3 var\cf0  big_n, twopi_over_n;\
	big_n = xk.real.size;\
	twopi_over_n = 2pi/big_n;\
	big_n.collect(\{ \cf3 arg\cf0  n;\
		big_n.collect(\{ \cf3 arg\cf0  k;\
			\cf3 Complex\cf0 (xk.real[k], xk.imag[k]) *\
			\cf3 Complex\cf0 (cos(twopi_over_n * k * n), sin(twopi_over_n * k * n));\
			\}).sum;\
		\}).real;\
	\}\
)\
\
\cf2 // let's test it\cf0 \
x = \cf3 Signal\cf0 .newClear(n);\
x.sineFill2([[4.0, 1.0, 0.25pi]]);\
x.plot.(minval: -1.0, maxval: 1.0);\
\
\cf2 // take DFT of x\cf0 \
a = ~dft.value(x);\
a.magnitude.plot(minval: 0.0, maxval: 1.0);\
\
\cf2 // plot the phase of the sinusoid\cf0 \
(a.phase * a.magnitude * 2).plot\
\
\cf2 // take IDFT of a\cf0 \
w = ~idft.value(a);\
w.plot(minval: -1.0, maxval: 1.0);\
\
\cf2 // test they are the same signal\cf0 \
(w - x).plot(minval: -1.0, maxval: 1.0);\
\
}