{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Candara;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs44 \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf2 // main variation variables:\cf0 \
		\cf3 var\cf0  variation = 1640;\
		\cf3 var\cf0  piecelength = 40;\
\
\cf2 // main functions:\cf0 \
		\cf3 var\cf0  isEven = \{\cf3 arg\cf0  n;\
			(n%2==0);\
		\};\
		\
		\cf3 var\cf0  getDur = \{\cf3 arg\cf0  dur, length;\
			(dur / (variation / length));\
		\};\
		\
		\cf3 var\cf0  getPrimes = \{ \cf3 arg\cf0  n;\
			\cf3 var\cf0  tempPrimes = \cf3 Array\cf0 .new();\
			\cf3 var\cf0  p = \cf3 Array\cf0 .series(n, 2, 1); \cf2 // fill array p with [2 through n]\cf0 \
			while ( \{ p.size > 0 \}, \{ \
				x = p[0];\
				tempPrimes = tempPrimes.add(x);\
				p.removeAllSuchThat(\{ \cf3 arg\cf0  item, i; item % x == 0 \});\
			 \});\
			tempPrimes;\
		\};\
		\
		\cf3 var\cf0  getFactors = \{ \cf3 arg\cf0  n;\
			\cf3 var\cf0  factors;\
			if(n.even)\
				\{forBy (2, sqrt(n), 2, \
				  	\{ \cf3 arg\cf0  i; \
					  	if (n%i==0 && isEven.value(n/i))\
					  	\{factors = factors.add([i,n/i])\}\
					\});				\
				\}\{ \cf4 "the number is odd"\cf0 \};\
			factors;\
		\};\
		\
		\cf3 var\cf0  getGoldbach = \{ \cf3 arg\cf0  n;\
			\cf3 var\cf0  testPrimes = getPrimes.value(n);\
			\cf3 var\cf0  results = \cf3 Array\cf0 .new();\
			for (0, testPrimes.size-1, \{\cf3 arg\cf0  i;\
				if (testPrimes.includes(n-testPrimes[i]),\
					\{results = results.add([testPrimes[i], n-testPrimes[i]])\}\
				);\
			\});\
			results\
		\};\
\
\cf2 // boot server\cf0 \
	\cf3 Server\cf0 .default = s = \cf3 Server\cf0 .internal.boot;\
	s.scope;\
	s.waitForBoot(\{	\
		\
		\cf2 // prepare buffer\cf0 \
		\cf3 var\cf0  data, routFunction, sd, myBuffers, buffer1,buffer2,buffer3, cond;\
		cond = \cf3 Condition\cf0 .new;\
\
		buffer1 = \cf3 CtkBuffer\cf0 .buffer(8192, server: s).load;\
		buffer2 = \cf3 CtkBuffer\cf0 .buffer(8192, server: s).load;\
		buffer3 = \cf3 CtkBuffer\cf0 .buffer(8192, server: s).load;\
\
		buffer1.sine1(0.0, 1, 1, 1, 1);\
		buffer2.sine1(0.0, 1, 1, 1, 0.5, 0.8, 0.4, 0.2, 0.9);\
		buffer3.sine1(0.0, 1, 1, 1, 1.0, 0.2, 0.7, 0.1, 0.6, 0.1, 0.8);\
		\
		s.sync(cond);\
		\cf4 "Buffers are loaded!"\cf0 .postln;\
		\
		myBuffers = [buffer1, buffer2, buffer3];\
		\
		\cf3 CmdPeriod\cf0 .doOnce(\{\
			\cf4 "Freeing Buffers"\cf0 .postln;\
						myBuffers.do(\{\cf3 arg\cf0  thisBuffer;\
				thisBuffer.free;\
			\})\
\
		\});\
		\
		\
		\cf2 // define SynthDef\cf0 \
		sd = \cf3 CtkSynthDef\cf0 (\cf5 \\note\cf0 , \{\cf3 arg\cf0  buffer, freq, amp, dur;\
			\cf3 var\cf0  env;\
			env = \cf3 EnvGen\cf0 .kr(\
				\cf3 Env\cf0 ([0, 1, 1, 0], [0.1, 0.8, 0.1], \cf5 \\sin\cf0 ), \
				timeScale: dur);\
			\cf3 Out\cf0 .ar(0, \cf3 Pan2\cf0 .ar(\
				\cf3 Osc\cf0 .ar(buffer, freq, 0, amp) * env\
				)\
			)\
		\});\
\
		routFunction = \{\cf3 arg\cf0  fundamental = variation, length = piecelength, buffer = buffer1, pause = 0;\
			var routine;\
			\cf3 var\cf0  partitions = getGoldbach.(fundamental);			routine = Routine(\{\
				pause.wait;\
				partitions.do(\{\cf3 arg\cf0  thisData, i;\
				\cf3 	var\cf0  freq, dur;\
					#freq, dur = thisData;\
					dur = getDur.value(dur, length);\
					sd.note(0.2, dur).buffer_(buffer).freq_(freq).dur_(dur).amp_(0.3).play;\
					\
				\});\
			\});\
			routine;	\
		\};\
	\
		\cf3 Routine\cf0 .run(\{	\
			\cf3 var\cf0  factors, length, routine, pause;\
			routine = [routFunction.value().play];\
			routine = routine.add(routFunction.value(length: piecelength-20, pause:10, buffer: buffer2).play;);\
			routine = routine.add(routFunction.value(length: piecelength-30, pause:20, buffer: buffer3).play;);\
		\})\
\}) \cf2 // end wait for boot	\cf0 \
}