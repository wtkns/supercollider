{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Candara;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green0\blue191;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs44 \cf2 (\
\
\cf3 // main variation variables:\cf2 \
		\cf4 var\cf2  variation = 440;\
		\cf4 var\cf2  piecelength = 40;\
\
\cf3 // main functions:\cf2 \
		\cf4 var\cf2  isEven = \{\cf4 arg\cf2  n;\
			(n%2==0);\
		\};\
		\
		\cf4 var\cf2  getDur = \{\cf4 arg\cf2  dur, length;\
			(dur / (variation / length));\
		\};\
		\
		\cf4 var\cf2  getPrimes = \{ \cf4 arg\cf2  n;\
			\cf4 var\cf2  tempPrimes = \cf4 Array\cf2 .new();\
			\cf4 var\cf2  p = \cf4 Array\cf2 .series(n, 2, 1); \cf3 // fill array p with [2 through n]\cf2 \
			while ( \{ p.size > 0 \}, \{ \
				x = p[0];\
				tempPrimes = tempPrimes.add(x);\
				p.removeAllSuchThat(\{ \cf4 arg\cf2  item, i; item % x == 0 \});\
			 \});\
			tempPrimes;\
		\};\
		\
		\cf4 var\cf2  getFactors = \{ \cf4 arg\cf2  n;\
			\cf4 var\cf2  factors;\
			if(n.even)\
				\{forBy (2, sqrt(n), 2, \
				  	\{ \cf4 arg\cf2  i; \
					  	if (n%i==0 && isEven.value(n/i))\
					  	\{factors = factors.add([i,n/i])\}\
					\});				\
				\}\{ \cf5 "the number is odd"\cf2 \};\
			factors;\
		\};\
		\
		\cf4 var\cf2  getGoldbach = \{ \cf4 arg\cf2  n;\
			\cf4 var\cf2  testPrimes = getPrimes.value(n);\
			\cf4 var\cf2  results = \cf4 Array\cf2 .new();\
			for (0, testPrimes.size-1, \{\cf4 arg\cf2  i;\
				if (testPrimes.includes(n-testPrimes[i]),\
					\{results = results.add([testPrimes[i], n-testPrimes[i]])\}\
				);\
			\});\
			results\
		\};\
\
\cf3 // boot server\cf2 \
	\cf4 Server\cf2 .default = s = \cf4 Server\cf2 .internal.boot;\
	s.scope;\
	s.waitForBoot(\{	\
		\
		\cf3 // prepare buffer\cf2 \
		\cf4 var\cf2  data, routFunction, sd, myBuffers, buffer1,\cf0 buffer2,buffer3,\cf2  cond;\
		cond = \cf4 Condition\cf2 .new;\
\cf0 \
		buffer1 = \cf6 CtkBuffer\cf0 .buffer(8192, server: s).load;\
		buffer2 = \cf6 CtkBuffer\cf0 .buffer(8192, server: s).load;\
		buffer3 = \cf6 CtkBuffer\cf0 .buffer(8192, server: s).load;\
\
		buffer1.sine1(0.0, 1, 1, 1, 1);\
		buffer2.sine1(0.0, 1, 1, 1, 0.5, 0.8, 0.4, 0.2, 0.9);\
		buffer3.sine1(0.0, 1, 1, 1, 1.0, 0.2, 0.7, 0.1, 0.6, 0.1, 0.8);\
		\cf2 \
		s.sync(cond);\
		\cf5 "Buffers are loaded!"\cf2 .postln;\
		\
		\cf0 myBuffers = [buffer1, buffer2, buffer3];\
		\cf2 \
		\cf4 CmdPeriod\cf2 .doOnce(\{\
			\cf5 "Freeing Buffers"\cf2 .postln;\
			\cf0 			myBuffers.do(\{\cf6 arg\cf0  thisBuffer;\
				thisBuffer.free;\
			\})\
\cf2 \
		\});\
		\
		\
		\cf3 // define SynthDef\cf2 \
		sd = \cf4 CtkSynthDef\cf2 (\cf7 \\note\cf2 , \{\cf4 arg\cf2  buffer, freq, amp, dur;\
			\cf4 var\cf2  env;\
			env = \cf4 EnvGen\cf2 .kr(\
				\cf4 Env\cf2 ([0, 1, 1, 0], [0.1, 0.8, 0.1], \cf7 \\sin\cf2 ), \
				timeScale: dur);\
			\cf4 Out\cf2 .ar(0, \cf4 Pan2\cf2 .ar(\
				\cf4 Osc\cf2 .ar(buffer, freq, 0, amp) * env\
				)\
			)\
		\});\
\
		routFunction = \{\cf4 arg\cf2  fundamental, length = piecelength, buffer;\
			var routine;\
			\cf4 var\cf2  partitions = getGoldbach.(fundamental);			routine = Routine(\{\
				partitions.do(\{\cf4 arg\cf2  thisData, i;\
				\cf4 	var\cf2  freq, dur;\
					#freq, dur = thisData;\
					dur = getDur.value(dur, length);\
					sd.note(0.2, dur).buffer_(buffer).freq_(freq).dur_(dur).amp_(0.3).play;\
				\});\
			\});\
			routine;	\
		\};\
	\
		\cf4 Routine\cf2 .run(\{	\
			\cf4 var\cf2  factors, length, routine;			factors = getFactors.value(variation);\
			factors.postln;\
			factors.do\cf0 (\{\cf6 arg\cf0  thisData, i;\
				\cf6 	var\cf0  freq, dur;\
					#dur, freq = thisData;\cf2 \
						routine = routFunction.value(freq, length: dur, buffer:  buffer2).play;\
			\})			\cf0 \
\cf2 		\})\
\}) \cf3 // end wait for boot	\cf2 \
)}