{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red96\green96\blue96;
\red0\green0\blue191;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural

\f0\fs24 \cf2 // ICMC 2006 Tutorial - Terry A. Lee\cf3 \
\
\cf2 // USING THIS TUTORIAL:\cf3 \
\cf2 // This tutorial was designed so that each line of code should be executed\cf3 \
\cf2 // sequentially.  Code within parentheses should be executed all at once.\cf3 \
\cf2 // code without parenthesis may be executed line by line. Anything preceeded by\cf3 \
\cf2 // two forward slashes (//) is a comment and need not be executed.\cf3 \
\
\cf2 // To execute a single line of code, place your cursor on that line of code\cf3 \
\cf2 // and press the <enter> key (not the <return> key).  Execute code wrapped in \cf3 \
\cf2 // parentheses all at once.  Double click on the opening parenthesis to select all\cf3 \
\cf2 // the code within, and then press the <enter> key to execute it all at once.\cf3 \
 \
\cf2 // Before running this tutorial, change the following string to point to the location \cf3 \
\cf2 // of the ICMC directory on your computer.  Then execute it by pressing <enter>\cf3 \
\cf2 // (not <return>).  This is needed for the tutorial to find the file path to\cf3 \
\cf2 // the example soundfiles.\cf3 \
p = \cf4 "/Users/tlee/Desktop/ICMC"\cf3 ;\
\
\cf2 // First thing: boot the server (execute code in parenthesis all at once)\cf3 \
(\
s = \cf5 Server\cf3 .local;\
s.options.blockSize = 16;\
s.boot;\
)\
\
\
\
\
\cf2 // Define a simple grain SynthDef based on a Sine Oscillator\cf3 \
\cf2 // and send it to the server.\cf3 \
(\
	\cf5 SynthDef\cf3 (\cf6 \\sinegrain\cf3 , \{ \cf5 arg\cf3  out, dur, freq, amp, pan;\
		\
		\cf5 var\cf3  env, sound;\
		\
		\cf2 // generate an envelope\cf3 \
		env   = \cf5 EnvGen\cf3 .kr(\cf5 Env\cf3 .sine(dur, amp), doneAction: 2);\
		\
		\cf2 // generate the sound\cf3 \
		sound = \cf5 FSinOsc\cf3 .ar(freq);\
		\
		\cf2 // multiply the envelope by the sound, pan it, and send it to the out bus\cf3 \
		\cf5 Out\cf3 .ar(out, \cf5 Pan2\cf3 .ar(sound * env, pan))\
	\
	\}).send(s);\
)\
\
\
\
\
\
\
\
\
\
\
\cf2 // Create a new GranCloud Object, store the object in variable a.\cf3 \
a = \cf5 GranCloud\cf3 .new; \
\
\cf2 // Tell the object what SynthDef to use as a template for the grains\cf3 \
a.def = \cf6 \\sinegrain\cf3 ;\
\
\cf2 // Set the center values of the grain attributes\cf3 \
a.center[\cf6 \\rate\cf3 ] = 0.01;	\cf2 // grain rate in number of seconds between grain start times\cf3 \
a.center[\cf6 \\dur\cf3 ]  = 0.02;	\cf2 // duration of the grain envelope in seconds\cf3 \
a.center[\cf6 \\freq\cf3 ] = 440;	\cf2 // the frequency of the grain waveform in Hertz\cf3 \
\
\cf2 // or use the shortcut syntax (same as a.center[\\amp])\cf3 \
a[\cf6 \\amp\cf3 ]  = 0.1;	        \cf2 // the amplitude of the envelope (0 to 1)\cf3 \
a[\cf6 \\pan\cf3 ]  = 0;		    \cf2 // a pan position (0 to 1)\cf3 \
\
\cf2 // Note that the following two lines do the same thing.  The second is a shortcut.\cf3 \
a.center[\cf6 \\pan\cf3 ] = 0;  \
a[\cf6 \\pan\cf3 ] = 0;		 \cf2 // this is a shortcut\cf3 \
\
\
\cf2 // Now play the cloud\cf3 \
a.play(s);\
\
\cf2 // Stop the cloud\cf3 \
a.stop;\
\
\
\
\
\cf2 // Ok great, but that sound is really not so interesting.\cf3 \
\cf2 // Rembember that grain parameter values are calculated using\cf3 \
\cf2 // the following formula:\cf3 \
\
\cf2 //    parameterValue = centerValue + distributionFunction(devValue);\cf3 \
\
\cf2 // Let's set some deviation values to make it more interesting.\cf3 \
a.play(s);\
\
\cf2 // Set random deviation values \cf3 \
a.dev[\cf6 \\rate\cf3 ] = 0.005;\
a.dev[\cf6 \\dur\cf3 ]  = 0.01;\
a.dev[\cf6 \\freq\cf3 ] = 100;\
a.dev[\cf6 \\amp\cf3 ]  = 0.07;\
a.dev[\cf6 \\pan\cf3 ]  = 0.75;\
\
a.stop;\
\
\
\
\
\
\
\
\
\
\
\
\cf2 // The function used to generate the random distribution can be changed\cf3 \
\cf2 // for any grain parameters.\cf3 \
a.play(s);\
\
\cf2 // May use any symolic name of an standard unary SC random function\cf3 \
a.dist[\cf6 \\freq\cf3 ] = \cf6 \\rand2\cf3 ;			 \cf2 // default, linear distribution (-dev to dev)\cf3 \
a.dist[\cf6 \\freq\cf3 ] = \cf6 \\sum3rand\cf3 ;		 \cf2 // bell-like distribution (-dev to dev)\cf3 \
a.dist[\cf6 \\freq\cf3 ] = \cf6 \\rand\cf3 ;			 \cf2 // linear (0 to dev)\cf3 \
\
\cf2 // Define your own random distribution function.  Any function that receives the dev \cf3 \
\cf2 // value as a parameter and returns a number may be used.\cf3 \
a.dist[\cf6 \\freq\cf3 ] = \{ \cf5 arg\cf3  dev; dev.squared - (100 * dev) \};  \
a.dist[\cf6 \\freq\cf3 ] = \{ \cf5 arg\cf3  dev; dev.rand2.cos * 50 \};  \
\
\cf2 // Reset back to pseudo-gaussian before continuing on.\cf3 \
a.dist[\cf6 \\freq\cf3 ] = \cf6 \\sum3rand\cf3 ;\
a.dist[\cf6 \\amp\cf3 ]  = \cf6 \\sum3rand\cf3 ;\
a.stop; \
\
\
\
\
\
\
\
\
\
\cf2 // Some other important instance variables:\cf3 \
\
\cf2 // duration tells the cloud how long to play\cf3 \
a.duration = \cf5 inf\cf3 ; 	\cf2 // default, plays until the stop command is issued\cf3 \
a.duration = 2;		\cf2 // stops playing after 2 seconds\cf3 \
a.play(s);\
a.stop;\
\
\cf2 // args is a more efficient way of setting grain parameters that do not change\cf3 \
\cf2 // from grain to grain.  It should contain an array of name value pairs.\cf3 \
\cf2 // First, clear data from the center data\cf3 \
a.duration = \cf5 inf\cf3 ;\
a[\cf6 \\amp\cf3 ]  = \cf5 nil\cf3 ;\
a[\cf6 \\pan\cf3 ]  = \cf5 nil\cf3 ;\
\
\cf2 // Now set it in the args array\cf3 \
a.args = [ \cf6 \\amp\cf3 , 0.1, \cf6 \\pan\cf3 , 0 ];\
a.play(s);\
\
\cf2 // Change the values (must send the entire array)\cf3 \
a.args = [ \cf6 \\amp\cf3 , 0.2,  \cf6 \\pan\cf3 , -1 ];\
a.args = [ \cf6 \\amp\cf3 , 0.01, \cf6 \\pan\cf3 , 1 ];\
a.stop;\
\
\cf2 // Set it back to use the center values before continuting\cf3 \
a.args   = \cf5 nil\cf3 ;\
a[\cf6 \\amp\cf3 ]  = 0.1; a[\cf6 \\pan\cf3 ]  = 0;\
\
\
\cf2 // map may be used to map grain parameters to control busses\cf3 \
\
\cf2 // Write a sine shaped frequency control to control bus 1\cf3 \
\cf2 // and Cosine shaped amplitude control to control but 2\cf3 \
c = \{ \cf5 Out\cf3 .kr(1, \cf5 SinOsc\cf3 .kr(0.3, [ 0, 0.5pi], [ 150, 0.1 ], [ 400, 0.15])) \}.play; \
\
\cf2 // clear the center values first;\cf3 \
a[\cf6 \\freq\cf3 ] = \cf5 nil\cf3 ;\
a[\cf6 \\amp\cf3 ]  = \cf5 nil\cf3 ;\
\
\cf2 // Use map to map the frequency and amp to the external control signals.\cf3 \
\cf2 // It should contain an array of controlName/busIndex pairs.\cf3 \
a.map = [ \cf6 \\freq\cf3 , 1, \cf6 \\amp\cf3 , 2 ];\
a.play(s);\
\
\cf2 // Stop the control signal and cloud\cf3 \
c.free;\
a.stop;\
\
\cf2 // reset variables before continuing on\cf3 \
a.map = \cf5 nil\cf3 ;\
a[\cf6 \\freq\cf3 ] = 300;\
a[\cf6 \\amp\cf3 ]  = 0.1;\
\
\
\
\
\
\cf2 // Control Specs may be used to constrain the results of center/dev calculations\cf3 \
\cf2 // to a set range and step size.  They are also handy for use when building \cf3 \
\cf2 // GUI's to set a range and warp on the the control.  Control specs can be set\cf3 \
\cf2 // for constraints for three different parameter values: (1) spec - for the output\cf3 \
\cf2 // of the center/dev/dist calculation, (2) centerSpec - for the center value only, \cf3 \
\cf2 // and (3) devSpec - for the deviation value only.  Control Specs are important\cf3 \
\cf2 // when using GranCloud with a GUI like GranCloud GUI, but are rarely used otherwise.\cf3 \
\
\cf2 // Add control specs to the output of the grain argument calculations\cf3 \
\cf2 // There are different ways of defining a control Spec in SC.\cf3 \
a.play(s);\
a.spec[\cf6 \\rate\cf3 ] = \cf5 ControlSpec\cf3 .new(0, 1.0, \cf6 'linear'\cf3 ); \cf2 // create a new ControlSpec\cf3 \
a.spec[\cf6 \\dur\cf3 ]  = [ 0.001, 1.0].asSpec;	 	       \cf2 // shortcut from an array\cf3 \
a.spec[\cf6 \\freq\cf3 ] = \cf6 \\freq\cf3 .asSpec;         	           \cf2 // some have predefined specs\cf3 \
a.spec[\cf6 \\amp\cf3 ]  = \cf6 \\amp\cf3 .asSpec;\
a.spec[\cf6 \\pan\cf3 ]  = \cf6 \\pan\cf3 .asSpec;\
\
\cf2 // Applies only to center value before rand dev is added\cf3 \
a.centerSpec[\cf6 \\freq\cf3 ] = [ 100, 500, \cf6 'exp'\cf3 , 50 ].asSpec;\
\
\cf2 // Applies only to the result of the deviation/distribution calculation before \cf3 \
\cf2 // it is added to center value\cf3 \
a.devSpec[\cf6 \\freq\cf3 ]    = [ -100, 100, \cf6 'lin'\cf3 , 50 ].asSpec;\
\
\cf2 // Demonstrate Range and Quantization constraint\cf3 \
a[\cf6 \\freq\cf3 ] = 500;  \cf2 // max range\cf3 \
a[\cf6 \\freq\cf3 ] = 800;  \cf2 // can't go this hi (uses max value of 500 instead)\cf3 \
a[\cf6 \\freq\cf3 ] = 100;  \cf2 // low range\cf3 \
a[\cf6 \\freq\cf3 ] = 50;   \cf2 // can't go lower (uses min value of 100 instead)\cf3 \
\
a[\cf6 \\freq\cf3 ] = 200;  \cf2 // bring it up to hear better\cf3 \
a[\cf6 \\freq\cf3 ] = 224;  \cf2 // quantization rounds down to 200, so no audible change\cf3 \
a[\cf6 \\freq\cf3 ] = 225;  \cf2 // quantization rounds up to 250, so we hear the change\cf3 \
\
\cf2 // before moving on, remove the center and dev specs\cf3 \
a.centerSpec.removeAt(\cf6 \\freq\cf3 );\
a.devSpec.removeAt(\cf6 \\freq\cf3 );\
\
a.stop;\
\
\
\
\
\cf2 // A more complex example\cf3 \
(\
	\
	\cf5 SynthDef\cf3 (\cf6 \\buf_filter_grain\cf3 , \{ \cf5 arg\cf3  out, dur, bufnum, bufRate, bufStartPos, filterFreq, filterQ, amp, pan, envCenter;\
		\
		\cf5 var\cf3  env, sound;\
		\
		\cf2 // generate an envelope with a changeable shape\cf3 \
		env = \cf5 EnvGen\cf3 .kr(\cf5 Env\cf3 .new([ 0, amp, 0 ], [ dur * envCenter, dur * (1 - envCenter) ], \cf6 'sine'\cf3 ), doneAction: 2);\
		\
		\cf2 // generate the sound\cf3 \
		sound = \cf5 PlayBuf\cf3 .ar(1, bufnum, bufRate * \cf5 BufRateScale\cf3 .kr(bufnum), 1, bufStartPos * \cf5 BufFrames\cf3 .kr(bufnum));\
		\
		\cf2 // apply grain by grain filtering and pan the sound\cf3 \
		sound = \cf5 BPF\cf3 .ar(sound, filterFreq, 1/filterQ);\
		\
		\cf2 // pan the signal and multiply by the envelope\cf3 \
		sound = \cf5 Pan2\cf3 .ar(sound * env, pan);\
		\
		\cf2 // write the sound to the out bus\cf3 \
		\cf5 Out\cf3 .ar(out, sound)\
	\
	\}).send(s);\
\
\
	\cf2 // a simple reverb synth\cf3 \
	\cf5 SynthDef\cf3 (\cf6 \\reverb\cf3 , \{ \cf5 arg\cf3  out, in, mix, decay, cutoff;\
		\cf5 var\cf3  sound, reverb;\
		sound = \cf5 In\cf3 .ar(in, 2);\
		reverb = sound;\
		6.do(\{\
			reverb = \cf5 AllpassN\cf3 .ar(\
				reverb, \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 				0.05, \
				[ \cf5 Rand\cf3 (0, 0.05), \cf5 Rand\cf3 (0, 0.5) ],\
				decay\
			)\
		\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf3 		\cf5 Out\cf3 .ar(out, \cf5 LeakDC\cf3 .ar( \cf5 LPF\cf3 .ar(reverb, cutoff) * mix ) )\
	\}).send(s);\
\
	\cf2 // read a noisy sound into a buffer\cf3 \
	\cf2 // FIX FILE PATH TO MATCH THE LOCATION ON YOUR COMPUTER!!!!\cf3 \
	b = \cf5 Buffer\cf3 .read(s, p ++ \cf4 "/noise2.aif"\cf3 );\
\
)\
\
\cf2 // start a reverb synth\cf3 \
r = \cf5 Synth\cf3 .tail(s, \cf6 \\reverb\cf3 , [ \cf6 \\out\cf3 , 0, \cf6 \\in\cf3 , 0, \cf6 \\mix\cf3 , 0.3, \cf6 \\decay\cf3 , 0.6, \cf6 \\cutoff\cf3 , 3000 ]);\
\
\cf2 // create a new GranCloud object and initialize some variables\cf3 \
(\
a = \cf5 GranCloud\cf3 .new;\
a.def = \cf6 \\buf_filter_grain\cf3 ;\
\
a.args = [ \cf6 \\bufnum\cf3 , b.bufnum ];  \cf2 // \\buf doesn't change grain to grain so set in args\cf3 \
\
a[\cf6 \\rate\cf3 ]           = 0.01;\
a.dev[\cf6 \\rate\cf3 ]       = 0.005;\
a[\cf6 \\dur\cf3 ]            = \{ \cf5 |g|\cf3  g[\cf6 \\rate\cf3 ] * 5 \};\
a.dev[\cf6 \\dur\cf3 ]        = 0.03;\
a[\cf6 \\bufRate\cf3 ]        = 1.0;\
a.dev[\cf6 \\bufRate\cf3 ]    = 0.5;\
a[\cf6 \\bufStartPos\cf3 ]    = 0.5;\
a.dev[\cf6 \\bufStartPos\cf3 ] = 0.1;\
a[\cf6 \\filterFreq\cf3 ]     = 680;\
a.dev[\cf6 \\filterFreq\cf3 ] = 300;\
a[\cf6 \\filterQ\cf3 ]        = 35;\
a.dev[\cf6 \\filterQ\cf3 ]    = 15;\
a[\cf6 \\amp\cf3 ]            = 4.0;\
a.dev[\cf6 \\amp\cf3 ]        = 0.1;\
a[\cf6 \\pan\cf3 ]            = 0;\
a.dev[\cf6 \\pan\cf3 ]        = 0.5;\
a[\cf6 \\mix\cf3 ]            = 0.5;\
a.dev[\cf6 \\mix\cf3 ]        = 0.5;\
a[\cf6 \\room\cf3 ]           = 0.5;\
a.dev[\cf6 \\room\cf3 ]       = 0.4;\
a[\cf6 \\damp\cf3 ]           = 0.5;\
a.dev[\cf6 \\damp\cf3 ]       = 0.4;\
a[\cf6 \\envCenter\cf3 ]      = 0.1;\
a.dev[\cf6 \\envCenter\cf3 ]  = 0.02;\
a.order = [ \cf6 \\rate\cf3 , \cf6 \\dur\cf3  ];\
a.play(s);\
)\
\
a.stop;\
\
\
\cf2 // Changing values over time\cf3 \
\
\cf2 // METHOD 1: Change values directly\cf3 \
a.play;\
a[\cf6 \\filterFreq\cf3 ] = 400;\
a[\cf6 \\filterFreq\cf3 ] = 600;\
a[\cf6 \\filterFreq\cf3 ] = 145.358594359;\
a[\cf6 \\filterFreq\cf3 ] = 440;\
\
\cf2 // change dev values\cf3 \
a.dev[\cf6 \\filterFreq\cf3 ] = 0;\
a.dev[\cf6 \\filterFreq\cf3 ] = 300;\
a.dev[\cf6 \\filterFreq\cf3 ] = 100;\
\
\cf2 // slow it down\cf3 \
a[\cf6 \\rate\cf3 ] = 0.1;\
a[\cf6 \\rate\cf3 ] = 0.01;\
a.stop;\
\
\
\
\
\
\
\
\
\
\
\cf2 // METHOD 2: Map values to a graphic interface of your creation\cf3 \
\
\cf2 // (select and execute all of this code at once)\cf3 \
(\
\cf2 // make sure we have valid center and dev specs\cf3 \
a.centerSpec[\cf6 \\filterFreq\cf3 ] = \cf6 \\freq\cf3 .asSpec;\
a.devSpec[\cf6 \\filterFreq\cf3 ] = [ 0, 1000, \cf6 'lin'\cf3 , 0 ].asSpec;\
\
\cf2 // create a new window and use a FlowLayout to make placement easier\cf3 \
w = \cf5 SCWindow\cf3 .new(\cf4 "My GUI"\cf3 , \cf5 Rect\cf3 (300, 300, 100, 250));\
w.view.decorator = \cf5 FlowLayout\cf3 (\cf5 Rect\cf3 (0, 0, w.bounds.width, w.bounds.height));\
w.view.background = \cf5 Color\cf3 .gray;\
\
\cf2 // create a play button\cf3 \
\cf5 SCButton\cf3 (w, \cf5 Rect\cf3 (0, 0, 54, 20))\
	.states_([ [ \cf4 "Play"\cf3 , \cf5 Color\cf3 .black, \cf5 Color\cf3 .green ], [ \cf4 "Stop"\cf3 , \cf5 Color\cf3 .black, \cf5 Color\cf3 .red ] ])\
	.action_(\{ \cf5 arg\cf3  box; if(box.value == 1, \{ a.play(s) \}, \{ a.stop \}) \});\
		\
w.view.decorator.nextLine;\
\
\cf2 // create a center and dev slider for freq input\cf3 \
\cf5 SCSlider\cf3 (w, \cf5 Rect\cf3 (0, 0, 25, 200))\
	.value_(a.centerSpec[\cf6 \\filterFreq\cf3 ].unmap(a[\cf6 \\filterFreq\cf3 ].value))\
	.action_(\{ \cf5 arg\cf3  slider; a[\cf6 \\filterFreq\cf3 ] = a.centerSpec[\cf6 \\filterFreq\cf3 ].map(slider.value) \});\
\
\cf5 SCSlider\cf3 (w, \cf5 Rect\cf3 (0, 0, 25, 200))\
	.value_(a.devSpec[\cf6 \\filterFreq\cf3 ].unmap(a.dev[\cf6 \\filterFreq\cf3 ].value))\
	.action_(\{ \cf5 arg\cf3  slider; a.dev[\cf6 \\filterFreq\cf3 ] = a.devSpec[\cf6 \\filterFreq\cf3 ].map(slider.value) \});\
	\
w.front;\
)\
a.stop;\
\
\
\
\cf2 // METHOD 3: Use a function\cf3 \
\
\cf2 // Create a new GranCloud object with preset SynthDef and grain parameters\cf3 \
a = \cf5 GranCloud\cf3 .preset(s, \cf6 \\glisson\cf3 );\
a.play(s);\
\
a[\cf6 \\startFreq\cf3 ] = \{ [ 110, 220, 440, 880 ].wchoose([ 0.2, 0.4, 0.3, 0.1 ]) \};\
\
a[\cf6 \\startFreq\cf3 ] = 440;\
a.stop;\
\
\cf2 // Functions passed arguments (grainArgs, centerArgs, devArgs, randArgs, playTime)\cf3 \
\cf2 // Allows grainArgs to be dependant upon one another\cf3 \
\
\cf2 // We must specify a processing order if we use dependencies\cf3 \
a.order = [ \cf6 \\rate\cf3 , \cf6 \\dur\cf3 , \cf6 \\startFreq\cf3 , \cf6 \\endFreq\cf3  ];\
a[\cf6 \\dur\cf3 ] = \{ \cf5 arg\cf3  grainArgs; 3.0 * grainArgs[\cf6 \\rate\cf3 ] \};\
\
a[\cf6 \\endFreq\cf3 ] = \{ \cf5 |g|\cf3  g[\cf6 \\startFreq\cf3 ] \};\
a.dev[\cf6 \\endFreq\cf3 ] = \{ \cf5 |g|\cf3  g[\cf6 \\startFreq\cf3 ] / 4 \};\
a.dev[\cf6 \\rate\cf3 ] = 0.005;\
a.dev[\cf6 \\dur\cf3 ] = 0;\
a.play;\
\
a[\cf6 \\rate\cf3 ] = 0.05;\
a[\cf6 \\rate\cf3 ] = 0.1;\
a[\cf6 \\startFreq\cf3 ] = 100;\
a[\cf6 \\startFreq\cf3 ] = 1000;\
a[\cf6 \\startFreq\cf3 ] = 240;\
a[\cf6 \\rate\cf3 ] = 0.01;\
\
a.stop;\
\
\
\
\cf2 // METHOD 4: Use an Env object\cf3 \
a[\cf6 \\startFreq\cf3 ] = \cf5 Env\cf3 ([ 220, 220, 1200, 880, 110, 600, 220 ], [ 1.0, 1.0, 2.0, 0.25, 0.25, 0.5 ], \cf6 'exponential'\cf3 );\
a.dev[\cf6 \\startFreq\cf3 ] = \cf5 Env\cf3 ([0, 200, 0], [ 6, 6 ], [ \cf6 'sine'\cf3 , \cf6 'linear'\cf3  ]);\
a[\cf6 \\startFreq\cf3 ].plot;\
a.dev[\cf6 \\startFreq\cf3 ].plot;\
a.play;\
a.stop;\
\
\
\cf2 // METHOD 5: Use Streams (Patterns and Streams)\cf3 \
\
\cf2 // randomly choose from the list of frequencies\cf3 \
a[\cf6 \\startFreq\cf3 ] = \cf5 Prand\cf3 ([ 440, 880, 220, 330 ], \cf5 inf\cf3 ).asStream;\
a.play;\
a[\cf6 \\startFreq\cf3 ] = \cf5 Pseq\cf3 ([ 440, 880, 220, 330, 550, 770 ], \cf5 inf\cf3 ).asStream;\
a.dev[\cf6 \\startFreq\cf3 ] = 0;\
a.dev[\cf6 \\endFreq\cf3 ] = 0;\
a[\cf6 \\rate\cf3 ] = 0.01;\
a.stop;\
\
\cf2 // a more complicated pattern\cf3 \
a[\cf6 \\startFreq\cf3 ] = \cf5 Pseq\cf3 ([ \cf5 Pseq\cf3 ([ 440, 880, 220, 330, 550, 770 ], 30), \cf5 Pseries\cf3 (100, 2, 200) ], 30).asStream;\
a.play;\
a.stop;\
\
\
\cf2 // LOOPING SUPPORT\cf3 \
\
\cf2 // set the freq back to an envelope\cf3 \
a[\cf6 \\startFreq\cf3 ] = \cf5 Env\cf3 .new([ 220, 220, 880, 880, 220, 330, 440 ], [ 1.0, 1.0, 1.0, 0.5, 0.5, 0.5 ], \cf6 'exponential'\cf3 );\
\
\cf2 // loop the freq value between 1 sec and 2 sec 4 times before moving on\cf3 \
a.loop[\cf6 \\startFreq\cf3 ] = [ 1.0, 2.0, 4 ];		\cf2 // [ startLoop, endLoop, numTimes ]\cf3 \
a.play;\
a.stop;\
\
\cf2 // set the entire cloud to loop from 1 sec to 2 sec 4 times before continuing on \cf3 \
a.loopAll = [ 1.0, 2.0, 4 ];\
a.play(s);\
a.stop;\
\
\
\cf2 // SO WHAT ABOUT THIS GUI THING\cf3 \
\
\cf2 // first build a new cloud\cf3 \
(	\
	\cf2 // create a new GranCloud based on a preset (server must be booted)\cf3 \
	a = \cf5 GranCloud\cf3 .preset(s, \cf4 "sine_grain"\cf3 ); \
	a.duration = 30;   \cf2 // GUI's really need a finite duration\cf3 \
	a.numChannels = 2; \cf2 // numChannels is needed for recording support in GranCloudGUI		\cf3 \
	\cf2 // set the center values of the grain attributes\cf3 \
	a[\cf6 \\rate\cf3 ] = 0.01;	\cf2 // grain rate in number of seconds between grain start times\cf3 \
	a[\cf6 \\dur\cf3 ]  = \{ \cf5 |g|\cf3  2.0 * g[\cf6 \\rate\cf3 ]  \};	\cf2 // duration of the grain envelope in seconds\cf3 \
	a[\cf6 \\freq\cf3 ] = \cf5 Env\cf3 ([ 110, 880 ], [ 5 ]);	\cf2 // the frequency of the grain waveform\cf3 \
	a[\cf6 \\amp\cf3 ]  = 0.1;	    \cf2 // the amplitude of the envelope (0 to 1)\cf3 \
	a[\cf6 \\pan\cf3 ]  = 0;		\cf2 // a pan position (0 to 1)\cf3 \
\
	\cf2 // deviation values\cf3 \
	a.dev[\cf6 \\rate\cf3 ] = 0.005;\
	a.dev[\cf6 \\dur\cf3 ]  = 0;\
	a.dev[\cf6 \\freq\cf3 ] = 40;\
	a.dev[\cf6 \\amp\cf3 ]  = 0.05;\
	a.dev[\cf6 \\pan\cf3 ]  = 0.5;\
\
	\cf2 //distribution function\cf3 \
	a.dist[\cf6 \\freq\cf3 ] = \cf6 \\sum3rand\cf3 ;	\
\
	\cf2 // loops		\cf3 \
	a.loopAll = [ 1, 3, 5 ];\
	a.loop[\cf6 \\rate\cf3 ] = [ 2, 3, 3 ];\
	a.loop[\cf6 \\dur\cf3 ]  = [ 4, 6, 4 ];\
	\
	\cf2 // specify processing order for dependencies (also controls order displayed in GranCloudGUI)\cf3 \
	a.order = [ \cf6 \\rate\cf3 , \cf6 \\dur\cf3 , \cf6 \\freq\cf3 , \cf6 \\amp\cf3 , \cf6 \\pan\cf3  ];\
	\
	\cf2 // ControlSpecs are important to GUI's to set the display range for sliders, etc...\cf3 \
	a.spec[\cf6 \\rate\cf3 ] = \cf5 ControlSpec\cf3 .new(0, 1.0, \cf6 'linear'\cf3 ); \cf2 // create a new ControlSpec\cf3 \
	a.spec[\cf6 \\dur\cf3 ]  = [ 0.001, 1.0].asSpec;	 	\cf2 // shortcut from an array\cf3 \
	a.spec[\cf6 \\freq\cf3 ] = \cf6 \\freq\cf3 .asSpec;         	\cf2 // some have predefined specs\cf3 \
	a.spec[\cf6 \\amp\cf3 ]	= \cf6 \\amp\cf3 .asSpec;\
	a.spec[\cf6 \\pan\cf3 ]  = \cf6 \\pan\cf3 .asSpec;\
\
	\cf2 // Now that the cloud has been initialized, open a GranCloudGUI for it\cf3 \
	b = \cf5 GranCloudGUI\cf3 .display(s, 0, 1, \cf4 "ICMC Tutorial"\cf3 , a);\
)\
\
\
\
\
\cf2 // ANOTHER GranCloudGUI EXAMPLE:\cf3 \
\
\cf2 // stop the reverberator we had running earlier\cf3 \
r.free;\
\
(\
\cf2 // Define SynthDef based on a buffer with a send for a reverb synth\cf3 \
	\cf5 SynthDef\cf3 (\cf6 \\buf_grain_send\cf3 , \{ \cf5 arg\cf3  out, reverbBus, dur, bufnum, bufRate, bufStartPos, amp, pan, envCenter, reverbMix;\
		\
		\cf5 var\cf3  env, sound;\
		\
		\cf2 // generate an envelope with a changeable shape\cf3 \
		env = \cf5 EnvGen\cf3 .kr(\cf5 Env\cf3 .new([ 0, amp, 0 ], [ dur * envCenter, dur * (1 - envCenter) ], \cf6 'sine'\cf3 ), doneAction: 2);\
		\
		\cf2 // generate the sound\cf3 \
		sound = \cf5 PlayBuf\cf3 .ar(1, bufnum, bufRate * \cf5 BufRateScale\cf3 .kr(bufnum), 1, bufStartPos * \cf5 BufFrames\cf3 .kr(bufnum));\
		\
		\cf2 // pan the signal and multiply by the envelope\cf3 \
		sound = \cf5 Pan2\cf3 .ar(sound * env, pan);\
		\
		\cf2 // write the sound to the out bus\cf3 \
		\cf5 Out\cf3 .ar(out, sound * (1 - reverbMix).squared);\
		\cf5 Out\cf3 .ar(reverbBus, sound * reverbMix.squared);\
	\
	\}).send(s);\
\
	\cf2 // a simple reverb synth\cf3 \
	\cf5 SynthDef\cf3 (\cf6 \\reverb\cf3 , \{ \cf5 arg\cf3  out, in, mix, decay, cutoff;\
		\cf5 var\cf3  sound, reverb;\
		sound = \cf5 In\cf3 .ar(in, 2);\
		reverb = sound;\
		6.do(\{\
			reverb = \cf5 AllpassN\cf3 .ar(\
				reverb, \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 				0.05, \
				[ \cf5 Rand\cf3 (0, 0.05), \cf5 Rand\cf3 (0, 0.5) ],\
				decay\
			)\
		\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li1700\fi-1700\ql\qnatural
\cf3 		\cf5 Out\cf3 .ar(out, \cf5 LeakDC\cf3 .ar( \cf5 LPF\cf3 .ar(reverb, cutoff) * mix ) )\
	\}).send(s);\
\
)\
\
	\
(\
	\cf2 // start reverb, mix level determined by grain send\cf3 \
	b = \cf5 Bus\cf3 .audio(s, 2);  \cf2 // reverb bus\cf3 \
	r = \cf5 Synth\cf3 .tail(s, \cf6 \\reverb\cf3 , [ \cf6 \\out\cf3 , 0, \cf6 \\in\cf3 , b.index, \cf6 \\mix\cf3 , 1.0, \cf6 \\decay\cf3 , 0.6, \cf6 \\cutoff\cf3 , 3000 ]);\
	\
	\cf2 // load soundfile to buffer\cf3 \
	d = \cf5 Buffer\cf3 .read(s, p ++ \cf4 "/JingStorm.aiff"\cf3 );\
	\
	\cf2 // create a new blank instance of GranCloud and store in in variable a.\cf3 \
	a = \cf5 GranCloud\cf3 .new; \
	a.def = \cf6 \\buf_grain_send\cf3 ;  \
	a.duration = \cf5 inf\cf3 ;\
	a.numChannels = 2;\
	a.duration = 60;\
		\
	\cf2 // static args\cf3 \
	a.args = [ \cf6 \\bufnum\cf3 , d.bufnum, \cf6 \\reverbBus\cf3 , b.index ];\
	\
	\cf2 // set the center values of the grain attributes (using the bracket shortcut)\cf3 \
	a[\cf6 \\rate\cf3 ] = 0.01;	\cf2 // grain rate in number of seconds between grain start times\cf3 \
	a[\cf6 \\dur\cf3 ]  = \{ \cf5 arg\cf3  g; 3.0 * g[\cf6 \\rate\cf3 ]  \};	\cf2 // duration of the grain envelope in seconds\cf3 \
	a[\cf6 \\bufRate\cf3 ] = 1;\
	a[\cf6 \\bufStartPos\cf3 ] = \cf5 Env\cf3 ([ 0, 1, 0, 1, 0, 1, 0, 1, 0.5 ], [ 5, 1, 2, 4, 3, 0.5, 1.0, 10 ], \cf6 'linear'\cf3 );\
	a[\cf6 \\amp\cf3 ]  = 0.1;	\cf2 // the amplitude of the envelope (0 to 1)\cf3 \
	a[\cf6 \\pan\cf3 ]  = 0;		\cf2 // a pan position (0 to 1)\cf3 \
	a[\cf6 \\envCenter\cf3 ] = 0.5;\
	a[\cf6 \\reverbMix\cf3 ] = \cf5 Env\cf3 ([0.1, 1.0, 0.4], [ 10, 10 ]);\
	\
	a.dist[\cf6 \\freq\cf3 ] = \cf6 \\sum3rand\cf3 ;\
	\
	a.dev[\cf6 \\rate\cf3 ] = 0.002;\
	a.dev[\cf6 \\dur\cf3 ]  = 0;\
	a.dev[\cf6 \\bufRate\cf3 ] = 0.1;\
	a.dev[\cf6 \\bufStartPos\cf3 ] = 0.002;\
	a.dev[\cf6 \\amp\cf3 ]  = 0.02;\
	a.dev[\cf6 \\pan\cf3 ]  = 0.3;\
	\
	a.order = [ \cf6 \\rate\cf3 , \cf6 \\dur\cf3 , \cf6 \\bufRate\cf3 , \cf6 \\bufStartPos\cf3 , \cf6 \\amp\cf3 , \cf6 \\pan\cf3 , \cf6 \\envCenter\cf3 , \cf6 \\reverbMix\cf3  ];\
	\
	a.spec[\cf6 \\rate\cf3 ] = \cf5 ControlSpec\cf3 .new(0, 1.0, \cf6 'linear'\cf3 ); \
	a.spec[\cf6 \\dur\cf3 ]  = [ 0.001, 1.0].asSpec;	 	\
	a.spec[\cf6 \\bufRate\cf3 ] = [ 0.25, 4.0 ].asSpec; \
	a.spec[\cf6 \\bufStartPos\cf3 ] = [ 0.0, 1.0 ].asSpec;\
	a.spec[\cf6 \\mix\cf3 ]  = [ 0, 1 ].asSpec;\
	a.spec[\cf6 \\amp\cf3 ]  = \cf6 \\amp\cf3 .asSpec;\
	a.spec[\cf6 \\pan\cf3 ]  = \cf6 \\pan\cf3 .asSpec;\
\
	b = \cf5 GranCloudGUI\cf3 .display(s, 0, 1, \cf4 "ICMC Tutorial"\cf3 , a);\
)\
\
a.play(s);\
d.free;\
b.free;\
r.free;\
\
\
\cf2 // tlee@tleestudio.com   www.tleestudio.com\cf3 \
}